<!--
 * @Author: Vanish
 * @Date: 2024-10-19 10:51:44
 * @LastEditTime: 2024-10-21 19:30:11
 * Also View: http://vanishing.cc
 * Copyright@ https://creativecommons.org/licenses/by/4.0/deed.zh-hans
-->
# 1.malloc,free,new,delete 的区别

## 答案

在C/C++中，malloc和free是标准库函数，用于手动管理内存，而new和delete是C++运算符，提供更高级的内存管理。new会自动计算所需内存、返回对象类型指针，并在分配失败时抛出异常，还会调用构造函数；而malloc则需手动计算内存、返回void*指针，并在分配失败时返回NULL。释放内存时，delete会调用析构函数，而free则不会.


## 背景

- malloc,free 是C/C++的标准库函数，用来分配和释放内存。
- new,delete 是C++的运算符，用来分配和释放内存。

## 差别

- new 自动计算需要分配内存大小,malloc需要手动计算
- new 返回对象类型指针,mallock返回void* 需要手动类型转换
- new 分配失败抛出异常,malloc分配失败返回NULL
- new 调用构造函数,malloc需要手动调用构造函数
- new 在free store(自由存储区)上分配内存,malloc在堆上分配内存
- delete 需要对象类型指针,free需要void* 
- delete 调用析构函数,malloc需要手动调用析构函数

## 知识补充

- new的步骤 
  - operator new
  - 申请足够的内存
  - 调用构造函数,初始化成员变量
- delete的步骤
  - 调用析构函数
  - operator delete
  - 释放内存

## 相关问题

- malloc是怎么分配空间的?
- malloc分配的是物理内存还是虚拟内存?
- malloc调用后是否立刻得到物理内存?
- free(p)如何知道该释放多大空间?

# 2.简述多态实现原理

## 答案
所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为.
C++的多态分为编译时多态和运行时多态.
编译时多态通过重载和模板来实现.
运行时多态通过继承和虚函数来实现.

## 知识背景

[多态实现原理](简述多态实现原理.km)

# 3.C++内存布局

## 答案

## 知识背景

C++内存区域:
- 堆: 使用 malloc free分配的空间
- 栈
- 静态存储区: 存储全局变量和静态变量
- 常量存储区: 存储常量
- 自由存储区: new delete 分配的空间

![C++内存布局](image-1.png)
- .text段:编译后程序主题,aka程序的机器指令
- .data段:初始化非零的全局变量,静态变量
- .rodata段:只读数据,例如字符串常量
- .bss段:未初始化的全局变量,被初始化为0的全局变量
- heap:动态分配的内存,向高地址方向增长
- stack:函数调用栈,向低地址方向增长

堆和栈的区别:

- 管理方式:栈自动管理,堆手动管理
- 空间大小:栈大小固定,堆大小可变
- 碎片问题:栈内存无碎片,堆内存容易产生碎片
- 生长方向:栈向低地址增长,堆向高地址增长
- 分配方式:堆都是动态分配的,栈有两种分配方式:静态分配和动态分配,其中静态分配由编译器完成的,动态分配由alloca函数完成.且栈的动态分配由编译器完成,无需手工实现.
- 分配效率: 栈效率高,堆效率低.计算机底层支持栈,堆的实现依靠c/c++函数库
### tips

- 虚函数表存放在 .rodata段

# 4.虚函数表和虚函数表指针的创建时机

## 答案
虚函数表编译时创建.
虚函数表指针在类对象构造时创建.

## 知识背景

虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。
当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数

- 虚函数表: 存放于类中,记录函数地址.
- 虚函数表指针: 存放在对象中,指向虚函数表的起始地址.

虚函数表的创建时机: 编译时

虚函数表指针的创建时机: 类对象构造时

有继承情况下虚函数表指针赋值过程:
- 1.调用父类构造函数,把A的虚函数表地址赋值给vptr
- 2.调用子类构造函数,把B的虚函数表地址赋值给vptr

# 5.进程和线程的区别

## 答案

- 进程是运行时的程序,是系统进行资源分配的基本单位,它实现了系统的并发.
- 线程是进程的子单位,是CPU调度的基本单位,也是独立运行的基本单位,它实现了进程内部的并发
- 一个程序至少拥有一个进程,一个进程至少拥有一个线程.
- 进程有独立的内存空间,线程共享进程的内存空间.
- 线程间的信息共享和通讯比较方便,不需要资源的切换.

## 概念

- 进程是资源分配的基本单位
- 线程是cpu调度的基本单位

## 区别

- 本质区别: 进程是资源分配的基本单位,线程是cpu调度的基本单位
- 内存: 进程有独立的虚拟内存空间,线程没有
- 所属关系: 一个线程只能属于一个进程,一个进程可以有多个线程
- 健壮性: 进程之间互不影响,线程崩溃会导致进程崩溃
- 并发性: 进程切换效率低,线程切换效率高


